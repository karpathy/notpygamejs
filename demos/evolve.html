<html>
<head>
<title>Canvas Artificial Life Evolution Simulation</title>

<script src="../include/npgmain.js"></script>
<script src="../include/vector2D.js"></script>
<script type="text/javascript">

var agents = [];
var food = [];
var generations = [];

// Initial genes values (mutating variables) - first ancestors should be viable-ish
var eyesep= 0.6; //separate of eyes in radians
var eyelen= 30; //how many pixels away from body eyes are
var eyesens= 0.0005; //how sensitive is the eye? decrease for more sensitivity...
var repthr= 3; // what is the replication threshold? in amount of food
var mutrate= 0.05; //how common are mutations? <0.5
var mutrate2= 0.3; //how severe are they when they do occur? <0.5
var rad= 15; //radius of agents

// laws of physics
var foodgain= 0.5; //how much food and replication is gained when agent eats?
var foodlosstospeedratio= 0.0005; //food loss per iteration for each speed unit
var foodaddfreq= 18; //how often do we add food?
var foodlimit= 60; //how much food can there be total?
var boostcost=0.001;  //how much does use of boost cost in health
var clonehandicap= 0.4; // the starting health of a respawned mutated clone when population gets too low.
var startagents= 20; // the starting number of agents

// fixed agent parameters not subject to mutation (yet)
var eyemult= 0.5; //linear multiplier on strength of eye.
var brainsize= 60; //how many neurons does each brain have. Must be bigger than about 10
var braindensity= 3; //how dense are the brains? (number of synapses per neuron)

//--------//--------
var generation= 0; // deepest generation reached by a lineage. Used to "remember" parameters for newly spawned agents.

function Brain()
{
  
  //1D array of neuron activations
  this.act= new Array(brainsize);
  for (var i=0;i<brainsize;i++) {
    this.act[i]= 0;
  }
  
  //2D array of synapse weights and indexes of neurons they connect to
  this.w= new Array(brainsize);
  this.ix= new Array(brainsize);
  for (var i=0;i<brainsize;i++) {
    this.w[i]= new Array(braindensity);
    this.ix[i]= new Array(braindensity);
    for (var j=0;j<braindensity;j++) {
        this.w[i][j]= randf(-1.2, 1.2);
        this.ix[i][j]= randi(0, brainsize);
    }
  }
  
}

//feeds forward the brain. s1 and s2 are the two senses, both in [0,1]
//health is ... health
Brain.prototype = {
    
    //brain takes inputs and sets its outputs
    tick : function(s1, s2) {

        this.act[0]= s1; //set inputs
        this.act[1]= s2;
        this.act[3]= 1; //some bias neurons are always on
        this.act[4]= 1;
        this.act[5]= 1;
        this.act[6]= 1;
        
        for (var i=7;i<brainsize;i++) {
            var a=0;
            for (var j=0;j<braindensity;j++) {
                a+= this.w[i][j]*this.act[this.ix[i][j]]
            }
            this.act[i]= 1.0/(1.0 + Math.exp(-a));  //pass through sigmoid
        }
        
        //assume last 2 neurons are the outputs
        return {
            out0: this.act[brainsize-1] - 0.5, 
            out1: this.act[brainsize-2]
        };
    },
    
    //used during reproduction
    //copy over the brain with some mutation. crude. for now
    mutateFrom : function(parent, a) {
		let brain = parent.brain
		console.log('reproducing');
		let mutrate = parent.mutrate;
		let mutrate2 = parent.mutrate2;
        //lossy copy of brain structure
        for (var i=0;i<brainsize;i++) {
          for (var j=0;j<braindensity;j++) {
            var m= brain.w[i][j];
            if(randf(0,1)<mutrate) {
				m += randn(0,mutrate2); 
				//mutrate /= 2;
			}
            this.w[i][j]= m;
            
            m= brain.ix[i][j];
            if(randf(0,1)<mutrate) {
				m = randi(0,brainsize);
				//mutrate /= 2;
			}
            this.ix[i][j]= m;
          }
        }
		// mutate speed
		a.speed = parent.speed * calcFactor(mutrate * 2, mutrate2);
		
		// mutate repthr
		a.repthr = parent.repthr * calcFactor(mutrate, mutrate2);
		
		// mutate mutation rate
		a.mutrate = Math.min(0.5, parent.mutrate * calcFactor(mutrate / 2, mutrate2));
		
		// mutate mutation severity
		a.mutrate2 = Math.min(0.5, parent.mutrate2 * calcFactor(mutrate / 5, mutrate2));
		
		// mutate eyesep
		a.eyesep = parent.eyesep * calcFactor(mutrate/2, mutrate2);
		
		// mutate eyelen
		a.eyelen = Math.max(parent.eyelen * calcFactor(mutrate/2, mutrate2), 1);
		
		// mutate eyesens
		a.eyesens = parent.eyesens * calcFactor(mutrate, mutrate2);
		
		// mutate rad
		a.rad = Math.min(30, parent.rad * calcFactor(mutrate * 2, mutrate2));
    }
}

let calcFactor = function(mutrate, mutrate2) {
	let factor = 1;
	if(randf(0,1)<mutrate) {
		let sign = randf(0,1) > 0.5? 1: -1;
		let r = randf(0,mutrate2)
		factor = 1 / (1+ (sign * r));
		if (factor <0) alert(`bug sign: ${sign} mutrate2: ${mutrate2} r: ${r}`);
	}
	return factor;
}

function Agent(){
    this.pos= new Vector2D(randf(0,WIDTH), randf(0,HEIGHT));
    this.dir= randf(0, 2*Math.PI);
    this.s1= 0;  //food sense eye 1
    this.s2= 0;  //food sense eye 2
    this.brain= new Brain();
    this.speed= 4.0;
    this.boost= 0.0; //boost, on top of speed
    this.health= 1.0;
    this.rep= 0.0; //replication counter
    this.selected= false;
	this.mutrate = mutrate;
	this.mutrate2 = mutrate2;
	this.repthr = repthr;
	this.generation = 0;
	this.children = 0;
	
	this.eyesep= eyesep;
	this.eyelen= eyelen;
	this.eyesens= eyesens;
	this.rad = rad;
}

function myinit(){
    counter = 0;
    
    //cosmetics
    ctx.font = "12pt Arial";
    ctx.strokeStyle="black";
    ctx.lineWidth="1.5";
}

let firstrun = true;
let numagents = 0;
function update(){
    counter=counter+1;
    
    killi=-1;
    for(i in agents) {
        var a = agents[i];
        
        //move agent
        var vel= new Vector2D((a.boost+a.speed)*Math.cos(a.dir), (a.boost+a.speed)*Math.sin(a.dir));
        a.pos.plusEq(vel);
        
        //enforce boundary conditions: wrap around if necessary
        if(a.pos.x<0) a.pos.x= WIDTH;
        if(a.pos.x>WIDTH) a.pos.x= 0;
        if(a.pos.y<0) a.pos.y= HEIGHT;
        if(a.pos.y>HEIGHT) a.pos.y= 0;
        
        //agent gets more hungry
//        a.health-= foodlosstospeedratio * a.speed / Math.max(a.rep / 2, 1); // faster agents loses health more rapidly, and well fed agents lose a smaller proportion of their health.
		let repfactor = a.rep > 1 ? a.rep: a.rep/2 + 0.5;
		repfactor = Math.min(repfactor, a.rad / 5); // bigger agents can benefit from becoming fat
        a.health-= foodlosstospeedratio * a.rad * a.speed / repfactor / 15; // agents loses health proportional to their size (area), better fed agents loses less health
		a.health-= foodlosstospeedratio*Math.pow(1000*a.eyesens, 1.5)/5; // the more sensitive the eye, the more it costs, quadratically
        a.health-= boostcost*a.boost; //boost costs health
        if(a.health<0) { killi= i; }
    }
    if(killi!=-1) {
		console.log(`A generation ${agents[i].generation} agent died! ${agents.length - 1} agents left`);
		agents.splice(killi, 1);
		
		// 5% chance of respawning a random old ancestor after generations stabilize
		if (generations.length > 0 && randf(0,1)<0.05) {
			console.warn(`An ancient specimen of generation ${randi(0, generations.length -1)} has been ressurrected`);
			agents.push(generations[randi(0, generations.length -1)]);
		}
	}
    
    //agent collision detection and resolution
    for(i in agents) {
        var a = agents[i];
        for(j in agents) {
            var a2 = agents[j];
            if(i==j) continue;
            var d= Math.sqrt(Math.pow(a.pos.x-a2.pos.x,2) + Math.pow(a.pos.y-a2.pos.y,2));
            var overlap= a.rad*2-d;
            if(overlap>0 && d>1){
                //one agent pushes on another proportional to his boost. Higher boost wins
                var aggression= a2.boost/(a.boost+a2.boost);
                if(a.boost<0.01 && a2.boost<0.01) aggression=0.5;
                var ff2= (overlap*aggression)/d;
                var ff1= (overlap*(1-aggression))/d;
                a2.pos.x+= (a2.pos.x-a.pos.x)*ff2;
                a2.pos.y+= (a2.pos.y-a.pos.y)*ff2;
                a.pos.x-= (a2.pos.x-a.pos.x)*ff1;
                a.pos.y-= (a2.pos.x-a.pos.x)*ff1;
            }
        }
    }
    
    //check if any agent ate food
    //and while we're at it, compute input to sense
    killi=-1;
    for(i in agents) {
        var a = agents[i];
        a.s1=0; a.s2=0;
        
        for(j in food) {
            var f = food[j];
            
            var d2= Math.sqrt(Math.pow(a.pos.x-f.pos.x,2) + Math.pow(a.pos.y-f.pos.y,2));
            if(d2 < a.rad){
                a.rep+= foodgain;
                a.health+= foodgain;
                if(a.health>1) a.health= 1;
                killi= j;
            }
            			
			//compute position of both eyes in world coordinates
			var x1= a.pos.x + a.eyelen*Math.cos(a.dir - a.eyesep);
			var y1= a.pos.y + a.eyelen*Math.sin(a.dir - a.eyesep);
			var x2= a.pos.x + a.eyelen*Math.cos(a.dir + a.eyesep);
			var y2= a.pos.y + a.eyelen*Math.sin(a.dir + a.eyesep);
			
			a.s1 += eyemult*Math.exp(-(Math.pow(1+a.eyesens*15/rad, 1/2)-1)*(Math.pow(x1-f.pos.x,2) + Math.pow(y1-f.pos.y,2)));
			a.s2 += eyemult*Math.exp(-(Math.pow(1+a.eyesens*15/rad, 1/2)-1)*(Math.pow(x2-f.pos.x,2) + Math.pow(y2-f.pos.y,2)));
        }
    }
    if(killi!=-1) food.splice(killi, 1);
    
    //feed forward the brain from senses to output
    for(i in agents) {
        var a = agents[i];
        res= a.brain.tick(a.s1, a.s2);
        
        //apply output neuron 0: controls turning. Also cap it to a max of 0.3 rotation
        var des= res.out0;
        if(des>0.9)des=0.9;
        if(des<-0.9)des=-0.9;
		a.health-= foodlosstospeedratio * Math.abs(des) *5; // turning costs health
        a.dir += des;
        
        //wrap direction around to keep it in range of [0, 2pi]
        if(a.dir>2*Math.PI) a.dir= a.dir-2*Math.PI;
        if(a.dir<0)a.dir=2*Math.PI+a.dir;
        
        //apply output neuron 1: controls boost
        des= res.out1;
        if(des>0) {a.boost= des;}
        else {a.boost= 0;}
     }
     
    //spawn more food, maybe
    if(counter%foodaddfreq==0 && food.length<foodlimit) {
        var f = {
            pos: new Vector2D(randf(0,WIDTH), randf(0,HEIGHT))
        };
        food.push(f);
    }
    
    //handle births
    var bi= -1;
    for(i in agents) {
        var a = agents[i];
        if(a.rep>repthr) {
            //this agent reproduces!
            bi= i;
        }
    }
    
    if(bi!=-1) {
        var a = agents[bi];
        a.rep -= Math.min(a.rep, a.rep*0.3 + 1);
		a.children++;
        
         var anew= new Agent();
         anew.pos=  new Vector2D(a.pos.x + randf(-30,30), a.pos.y + randf(-30,30));
         anew.brain.mutateFrom(a, anew);
        
		anew.generation = a.generation + 1;
		
		if (anew.generation > generation) {
			generation = anew.generation;
			console.log(`new generation depth:  ${generation}, born from agent ${JSON.stringify(a)}`);
			document.getElementById('generation').innerHTML = '' + generation;
			generations.push(a);
		}
		
        agents.push(anew);
    }
    
    //spawn more agents if there are too few agents left
    if(agents.length<Math.max(2,startagents - generation)) {
        var anew= new Agent();
		if (!firstrun) {
			let best;
			/*
			// selecting random live agent
			best = agents[Math.floor(randf(0, agents.length -1))];
			*/
			/*
			best = agents[0];
			for(i in agents) {
				var a = agents[i];
				// select oldest fit design. order by: most children, oldest generation (conservative, fairer and fosters safe evolution), most healthy.
				if (a.children > best.children || a.generation < best.generation || a.health > best.health) best = a;
			}*/
			
			// rolling back time to an extinct generation
			best = agents[0];
			for(i in agents) {
				var ancestor = agents[i];
				// select oldest fit design. order by: most children, oldest generation (conservative, fairer and fosters safe evolution), most healthy.
				if (a.generation < best.generation || a.children > best.children || a.health > best.health) best = a;
			}
			if (best.generation > 0) best = generations[best.generation - 1];
			
			anew.brain.mutateFrom(best, anew);
			anew.generation = best.generation;
			anew.health = clonehandicap; // respawned agents must be handicapped against reproduced ones.
			console.warn(`spawining new handicapped mutated clone of generation ${best.generation} with ${best.children} children and ${best.health} health`);
		}
        agents.push(anew);
    } else {
		firstrun = false;
	}
	if (numagents != agents.length) {
		numagents = agents.length;
		document.getElementById('agents').innerHTML = '' + numagents;
	}
}

function draw(){
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    
    //draw food
    ctx.fillStyle = 'rgb(100,230,100)';
    for(i in food) {
        var f = food[i];
        drawCircle(f.pos.x, f.pos.y, 10);
    }
    
    //draw all agents
    for(i in agents) {
        var a = agents[i];
        
        ctx.save();
        ctx.translate(a.pos.x, a.pos.y);
        ctx.rotate(a.dir - Math.PI/2);
        
        //draw its eyes
        //first compute their position
        var a1= -a.eyesep + Math.PI/2;
        var a2= a.eyesep + Math.PI/2;
        var x1= Math.cos(a1)*a.eyelen; var y1= Math.sin(a1)*a.eyelen;
        var x2= Math.cos(a2)*a.eyelen; var y2= Math.sin(a2)*a.eyelen;
        
        //draw the lines to eyes
        ctx.fillStyle = 'rgb(0,0,0)';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x1, y1);
        ctx.moveTo(0, 0);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.stroke();
        
        //draw the eyes, colored by how much food they sense
        var s= Math.round(a.s1*255.0);
        ctx.fillStyle = 'rgb('+s+',0,0)';
        drawCircle(x1, y1, 5)
        var s= Math.round(a.s2*255.0); if(s>255) s=255;
        ctx.fillStyle = 'rgb('+s+',0,0)';
        drawCircle(x2, y2, 5)
        
        //draw agent body and outline
        if (!a.selected){
            ctx.fillStyle = 'rgb('+Math.round(255.0*a.health)+','+Math.round(255.0*a.health)+',0)';
        } else {
            ctx.fillStyle = 'rgb(0,'+Math.round(255.0*a.health)+','+Math.round(255.0*a.health)+')';
        }
        drawCircle(0, 0, a.rad);
        ctx.restore();
        
        //draw brain of this agent, if it is selected
        if(a.selected) {
            
            //draw all the connections first
            ctx.fillStyle = 'rgb(0,0,0)';
            ctx.beginPath();
            var SS=100;
            for (var m=0;m<brainsize;m++) {
                var r1= 2*Math.PI*m/brainsize;
                for (var n=0;n<braindensity;n++) {
                    //this.w[i][j]*this.act[this.ix[i][j]]
                    var act= Math.round(a.brain.w[i][j]*120+120);
                    var r2= 2*Math.PI*a.brain.ix[m][n]/brainsize;
                    ctx.moveTo(SS*Math.cos(r1)+WIDTH-SS*1.5, SS*Math.sin(r1)+HEIGHT-SS*1.5);
                    ctx.lineTo(SS*Math.cos(r2)+WIDTH-SS*1.5, SS*Math.sin(r2)+HEIGHT-SS*1.5);
                }
            }
            ctx.stroke();
            
            for (var m=0;m<brainsize;m++) {
                //var act= 1.0/(1.0 + Math.exp(-a));  //pass through sigmoid
                var act= Math.round(a.brain.act[m]*255);
                ctx.fillStyle = 'rgb('+act+','+act+','+act+')';
                var r1= 2*Math.PI*m/brainsize;
                drawCircle(SS*Math.cos(r1)+WIDTH-SS*1.5, SS*Math.sin(r1)+HEIGHT-SS*1.5, 10);
            }
            
        }
    }
    
    //draw score
    //ctx.fillStyle = 'rgb(0,0,0)';
    //ctx.fillText("Alive: " + agents.length, 10, 20); 
}

function mouseClick(x, y){
    
    //select an agent with mouseclick
    var i;
    for(i in agents) {
        var a = agents[i];
        var d= Math.sqrt(Math.pow(a.pos.x-x,2) + Math.pow(a.pos.y-y,2));
        if(d<3*a.rad) {
        
            //that's a hit! Let's select this one and unselect all others
            var newset= !a.selected;
            var j;
            for(j in agents) { agents[j].selected= false; }
            a.selected= newset;
            
            return;
        }
    }
}

function keyUp(key){
}
function keyDown(key){
}

let isfast = false;
function togglefast() {
	NPGinit(isfast? 50: 500);
	isfast = !isfast;
}

function saveState() {
  let obj = {
    agents,
    food,
    generations,
    generation
  };
  save('evolution.json', JSON.stringify(obj));
}

function save(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

function handleFileSelect(evt) {
  var files = evt.target.files; // FileList object

  // Loop through the FileList and render image files as thumbnails.
  for (var i = 0, f; f = files[i]; i++) {

    var reader = new FileReader();

    // Closure to capture the file information.
    reader.onload = (function(theFile) {
      return function(e) {
        // Render thumbnail.
        let obj = JSON.parse(e.target.result);
        agents = obj.agents;
        food = obj.food;
        generations = obj.generations;
        generation = obj.generation;
      };
    })(f);

    // Read in the image file as a data URL.
    reader.readAsText(f);
  }
}
</script>

<style type="text/css">
canvas { 
    border: 1px solid #555;
    margin-top: 20px;
}
h1 {
    font-weight: normal;
    padding: 0;
    margin: 0;
}
h2 {
    font-weight: normal;
    font-size: 12px;
    
}
body {
    text-align: center;
    font-family: Verdana, Helvetica, sans-serif;
    font-size: 12px;
}
.ex{
    width: 500px;
    margin-left: auto;
    margin-right: auto;
}
</style>

</head>
<body onLoad="NPGinit(100);document.getElementById('files').addEventListener('change', handleFileSelect, false);">
<h1>Canvas Artificial Life evolutionary simulation v0.2</h1>
<h2>by <a href="http://twitter.com/#!/karpathy" target="_blank">@karpathy</a> and <a href="http://twitter.com/#!/jonathascarrijo" target="_blank">@jonathascarrijo</a><h2/>
<p>Click on a bot to select it and see its neural network activations.</p>
<p><button onclick="togglefast()">Toggle Fast</button> Generation depth: <span id="generation">0</span>&nbsp;&nbsp;&nbsp;Agents: <span id="agents"></span><button onclick="saveState()">Save</button> <input type="file" id="files" name="files[]" /><p>
<canvas id="NPGcanvas" width="1240" height="600">Browser not suppoerted for Canvas. Get a real browser.</canvas><br /><br />
<br />
<p>Hit CTRL+U to see source code, or visit <a href="https://github.com/jonathascarrijo/notpygamejs" target="_blank">GitHub project.</a> <br />This particular demo is only part of the more general GitHub project, which tries to simplify similar game-like canvas apps.</p>
<div class="ex">
<p>Basically, each creature has two eyes that sense amount of food. Both eyes act as input neurons in a brain, which is just a very simple Neural Network. The output nodes of the neural network turn them. If they accumulate food, they can reproduce with slight mutations in the weights of their brain.</p>
</div>
</body>
</html>
